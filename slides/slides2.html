<section>
  <h3>Elgamal (1985)</h3>
  <p>Extention of diffie-hellman</p>
  <p>Relies on DHP</p>
  <p>Uses a key tuple(x, k) where k is ephemeral</p>
  <p>Uses a subgroup q of the prime field p</p>
</section>
<section>
  <pre><code data-trim data-noescape>
p = 809
q = 101
g = randrange(2, q)
x = randrange(1, q)
y = pow(g, x, p)
def enc(m):
    k = randrange(2, q)
    c1 = pow(g, k, p)
    c2 = m * pow(y, k, p)
    return (c1, c2)
def dec(ct):
    c1, c2 = ct
    return c2 // pow(c1, x, p)
  </code></pre>
</section>
<section>
  <h3>Mathematical Groups</h3>
  <p>Collection of numbers upon which a binary operation is defined</p>
  <p>Operation must satisfy:</p>
  <ul>
    <li>Group closed under operation</li>
    <li>Associativity</li>
    <li>Identity element (0)</li>
    <li>Every element has an inverse</li>
  </ul>
</section>
<section>
  <h3>Abelian Groups</h3>
  <p>Superset of normal group, with the addition of commutativity</p>
</section>
<section>
  <h3>Elliptic Curves (EC)</h3>
  <p>Another esoteric field made surprisingly practical</p>
  <p>ECs are symmetric about the x-axis, meaning every element has an inverse</p>
  <p>Identity element is a point at infinity (because of Weierstrass form)</p>
  <p>Operations can be defined algebraicly as well as geometrically</p>
</section>
<section>
  <h3>Defining Addition on EC</h3>
  <img src="./img/point-addition.png" width="400" height="400">
</section>
<section>
  <h3>Scalar Multiplication</h3>
  <p>n * P is P + P repeated n times</p>
  <p>Can be implemeneted using same technique as modular exponentiation</p>
  <p>Runtime is the number of bits n has</p>
</section>
<section>
  <h3>EC Diffie-Hellman Problem</h3>
  <p>Given a point Q and a point P</p>
  <p>find an integer k so that P * k = Q</p>
</section>
<section>
  <h3>Domain Parameters</h3>
  <p>SECG has recommended curves and parameters</p>
  <p>Time for copy pasta</p>
</section>
<section>
  <h3>secp256k1</h3>
  <p>The Bitcoin curve</p>
  <p>Generally believed to be free of NSA meddling</p>
  <p>Faster than other curves due to it's construction</p>
</section>
<section>
  <h3>ECDH</h3>
  <pre><code data-trim data-noescape>
curve = curves["secp256k1"]
order = curve.n
Point = curve.g
bob_secret = randrange(1, order) # private
alice_secret = randrange(1, order) # private

alice_public_key = alice_secret * Point
bob_public_key = bob_secret * Point

shared_secret_bob = alice_public_key * bob_secret
shared_secret_alice = bob_public_key * alice_secret
  </code></pre>
</section>
<section>
  <h3>ECElgamal</h3>
  <pre><code data-trim data-noescape>
curve = curves["secp256k1"] # public
Point = curve.g # public
order = curve.n # public
x = randrange(1, order) # private key
Q = x * Point # public key
def enc(m):
    M = translateToCurve(m, curve) # place message on curve
    k = randrange(1, order) # private ephemeral key
    C1 = k * Point # public ephemeral key
    C2 = M + k * Q # encypted message
    return (C1, C2) # ciphertext pairing
def dec(ct):
    C1, C2 = ct
    return C2 - x * C1 # subtract keys from ciphertext to get M
  </code></pre>
</section>
<section>
  <h3>ECDSA</h3>
</section>
