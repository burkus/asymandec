<section>
  <h3>Elliptic Curves (EC)</h3>
  <p>Another esoteric field made surprisingly practical</p>
  <p>ECs are symmetric about the x-axis, meaning every element has an inverse</p>
  <p>Identity element is a point at infinity (Projective Geometry)</p>
  <p>Operations can be defined algebraicly as well as geometrically</p>
</section>
<section>
  <h3>Scalar Multiplication</h3>
  <p>n * P is P + P n times</p>
  <p>Can be implemeneted using same technique as modular exponentiation</p>
  <p>Runtime is the number of bits n has, O(lg(n))</p>
</section>
<section>
  <h3>Domain Parameters</h3>
  <p>SECG has recommended curves and parameters</p>
  <p>No need to generate them ourselves</p>
  <p>No runtime overhead as well</p>
</section>
<section>
  <h3>secp256k1</h3>
  <p>The Bitcoin curve</p>
  <p>Generally believed to be free of NSA meddling</p>
  <p>Koblitz curve, allows for about 30% faster verification than more standard curves.</p>
</section>
<section>
  <h3>ECDH</h3>
  <pre><code data-trim data-noescape>
curve = curves["secp256k1"]
order = curve.n
G = curve.g
bob_secret = randrange(1, order) # private
alice_secret = randrange(1, order) # private

alice_public_key = alice_secret * G
bob_public_key = bob_secret * G

shared_secret_bob = alice_public_key * bob_secret
shared_secret_alice = bob_public_key * alice_secret
  </code></pre>
</section>
<section>
  <h3>EC Diffie-Hellman Problem</h3>
  <p>Given a generator G and a point P</p>
  <p>Find the integer k so that G * k = P</p>
</section>
